<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cassette API Documentation · Cassette</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Cassette</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="disclaimers.html">Disclaimers</a></li><li><a class="toctext" href="whycassette.html">Why Cassette?</a></li><li><a class="toctext" href="overdub.html">The Overdubbing Mechanism</a></li><li><a class="toctext" href="contextualdispatch.html">Contextual Dispatch</a></li><li><a class="toctext" href="contextualpass.html">Contextual Compiler Pass Injection</a></li><li><a class="toctext" href="contextualtagging.html">Contextual Tagging of Values</a></li><li class="current"><a class="toctext" href="api.html">Cassette API Documentation</a><ul class="internal"></ul></li><li><a class="toctext" href="relatedwork.html">Related Work</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="api.html">Cassette API Documentation</a></li></ul><a class="edit-page" href="https://github.com/jrevels/Cassette.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Cassette API Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Cassette-API-Documentation-1" href="#Cassette-API-Documentation-1">Cassette API Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.Context" href="#Cassette.Context"><code>Cassette.Context</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Context{N&lt;:Cassette.AbstractContextName,
        M&lt;:Any,
        P&lt;:Cassette.AbstractPass,
        T&lt;:Union{Nothing,Cassette.Tag},
        B&lt;:Union{Nothing,Cassette.BindingMetaDictCache},
        H&lt;:Union{Nothing,Cassette.DisableHooks}}</code></pre><p>A type representing a Cassette execution context. This type is normally interacted with through type aliases constructed via <code>Cassette.@context</code>:</p><pre><code class="language-none">julia&gt; Cassette.@context MyCtx
Cassette.Context{nametype(MyCtx),M,P,T,B,H} where H&lt;:Union{Nothing,DisableHooks}
                                            where B&lt;:Union{Nothing,IdDict{Module,Dict{Symbol,BindingMeta}}}
                                            where P&lt;:AbstractPass
                                            where T&lt;:Union{Nothing,Tag}
                                            where M</code></pre><p><strong>Constructors</strong></p><p>Given a context type alias named e.g. <code>MyCtx</code>, an instance of the type can be constructed via:</p><pre><code class="language-none">MyCtx(; metadata = nothing, pass = Cassette.NoPass())</code></pre><p>To construct a new context instance using an existing context instance as a template, see the <code>similarcontext</code> function.</p><p>To enable contextual tagging for a given context instance, see the <a href="api.html#Cassette.enabletagging"><code>enabletagging</code></a> function.</p><p><strong>Fields</strong></p><ul><li><p><code>name::N&lt;:Cassette.AbstractContextName</code>: a parameter used to disambiguate different   contexts for overloading purposes (e.g. distinguishes <code>MyCtx</code> from other <code>Context</code> type   aliases).</p></li><li><p><code>metadata::M&lt;:Any</code>: trace-local metadata as provided to the context constructor</p></li><li><p><code>tag::T&lt;:Union{Nothing,Tag}</code>: the tag object that is attached to values when they are   tagged w.r.t. the context instance</p></li><li><p><code>pass::P&lt;:Cassette.AbstractPass</code>: the Cassette pass that will be applied to all method   bodies encountered during contextual execution (see the <a href="api.html#Cassette.@pass"><code>@pass</code></a> macro for details).</p></li><li><p><code>bindingscache::B&lt;:Union{Nothing,BindingMetaDictCache}}</code>: storage for metadata associated   with tagged module bindings</p></li><li><p><code>hooktoggle::H&lt;:Union{Nothing,DisableHooks}</code>: configuration toggle for disabling   the <code>overdub</code> pass&#39;s <code>prehook</code>/<code>posthook</code> injection (see <a href="api.html#Cassette.disablehooks"><code>disablehooks</code></a>   for details)</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/context.jl#L42-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.similarcontext" href="#Cassette.similarcontext"><code>Cassette.similarcontext</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">similarcontext(context::Context;
               metadata = context.metadata,
               pass = context.pass)</code></pre><p>Return a copy of the given <code>context</code>, where the copy&#39;s <code>metadata</code> and/or <code>pass</code> fields are replaced with those provided via the corresponding keyword arguments.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/context.jl#L121-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.disablehooks" href="#Cassette.disablehooks"><code>Cassette.disablehooks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">disablehooks(context::Cassette.Context)</code></pre><p>Return of copy of the given <code>context</code> with <code>prehook</code>/<code>posthook</code> injection disabled for the context. Disabling hook injection can reduce IR bloat in scenarios where these hooks are not being utilized.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/context.jl#L138-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.enabletagging" href="#Cassette.enabletagging"><code>Cassette.enabletagging</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">enabletagging(context::Cassette.Context, f)</code></pre><p>Return a copy of the given <code>context</code> with the tagging system enabled for the contextual execution of <code>f</code>.</p><p>Cassette uses the type of <code>f</code> to generate the <code>tag</code> field of the returned instance.</p><p>Note that it is generally unsafe to use the returned instance to contextually execute functions other than <code>f</code>. Specifically, in cases of nested contextual execution where both inner and outer contexts employ the tagging system, improper application of the tagged system could cause (for example) separate contexts to erroneously interfere with each other&#39;s metadata propagation.</p><p>See also: <a href="api.html#Cassette.hastagging"><code>hastagging</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/context.jl#L152-L169">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.hastagging" href="#Cassette.hastagging"><code>Cassette.hastagging</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hastagging(::Type{&lt;:Cassette.Context})</code></pre><p>Returns <code>true</code> if the given type indicates that the contextual tagging system is enabled for context instances of the type, returns <code>false</code> otherwise.</p><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; Cassette.@context MyCtx;

julia&gt; ctx = MyCtx();

julia&gt; Cassette.hastagging(typeof(ctx))
false

julia&gt; ctx = Cassette.enabletagging(ctx, sum);

julia&gt; Cassette.hastagging(typeof(ctx))
true</code></pre><p>See also: <a href="api.html#Cassette.enabletagging"><code>enabletagging</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/context.jl#L176-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.@context" href="#Cassette.@context"><code>Cassette.@context</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">Cassette.@context Ctx</code></pre><p>Define a new Cassette context type with the name <code>Ctx</code>. In reality, <code>Ctx</code> is simply a type alias for <code>Cassette.Context{Cassette.nametype(Ctx)}</code>.</p><p>Note that <code>Cassette.overdub</code> is automatically overloaded w.r.t. <code>Ctx</code> to define several primitives by default. A full list of these default primitives can be obtained by running:</p><pre><code class="language-none">methods(Cassette.overdub, (Ctx, Vararg{Any}))</code></pre><p>Note also that many of the default primitives&#39; signatures only match when contextual tagging is enabled.</p><p>See also: <a href="api.html#Cassette.Context"><code>Context</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/context.jl#L219-L238">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.overdub" href="#Cassette.overdub"><code>Cassette.overdub</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">overdub(context::Context, f, args...)</code></pre><p>Execute <code>f(args...)</code> overdubbed with respect to <code>context</code>.</p><p>More specifically, execute <code>f(args...)</code>, but with every internal method invocation <code>g(x...)</code> replaced by statements similar to the following:</p><pre><code class="language-none">begin
    prehook(context, g, x...)
    overdub(context, g, x...) # %n
    posthook(context, %n, g, x...)
    %n
end</code></pre><p>Otherwise, if Cassette cannot retrieve lowered IR for the method body of <code>f(args...)</code>, then <code>fallback(context, f, args...)</code> will be called instead. Cassette&#39;s <a href="api.html#Cassette.canrecurse"><code>canrecurse</code></a> function is a useful utility for checking if this will occur.</p><p>If the injected <code>prehook</code>/<code>posthook</code> statements are not needed for your use case, you can disable their injection via the <a href="api.html#Cassette.disablehooks"><code>disablehooks</code></a> function.</p><p>Additionally, for every method body encountered in the execution trace, apply the compiler pass associated with <code>context</code> if one exists. Note that this user-provided pass is performed on the method IR before method invocations are transformed into the form specified above. See the <a href="api.html#Cassette.@pass"><code>@pass</code></a> macro for further details.</p><p>If <code>Cassette.hastagging(typeof(context))</code>, then a number of additional passes are run in order to accomodate tagged value propagation:</p><ul><li><code>Expr(:new)</code> is replaced with a call to <code>Cassette.tagged_new</code></li><li><code>Expr(:splatnew)</code> is replaced with a call to <code>Cassette.tagged_splatnew</code></li><li>conditional values passed to <code>Expr(:gotoifnot)</code> are untagged</li><li>arguments to <code>Expr(:foreigncall)</code> are untagged</li><li>load/stores to external module bindings are intercepted by the tagging system</li></ul><p>The default definition of <code>overdub</code> is to recursively enter the given function and continue overdubbing, but one can interrupt/redirect this recursion by overloading <code>overdub</code> w.r.t. a given context and/or method signature to define new contextual execution primitives. For example:</p><pre><code class="language-none">julia&gt; using Cassette

julia&gt; Cassette.@context Ctx;

julia&gt; Cassette.overdub(::Ctx, ::typeof(sin), x) = cos(x)

julia&gt; Cassette.overdub(Ctx(), x -&gt; sin(x) + cos(x), 1) == 2 * cos(1)
true</code></pre><p>See also: <a href="api.html#Cassette.recurse"><code>recurse</code></a>, <a href="api.html#Cassette.prehook"><code>prehook</code></a>, <a href="api.html#Cassette.posthook"><code>posthook</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/overdub.jl#L616-L673">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.@overdub" href="#Cassette.@overdub"><code>Cassette.@overdub</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">Cassette.@overdub(ctx, expression)</code></pre><p>A convenience macro for executing <code>expression</code> within the context <code>ctx</code>. This macro roughly expands to <code>Cassette.recurse(ctx, () -&gt; expression)</code>.</p><p>See also: <a href="api.html#Cassette.overdub"><code>overdub</code></a>, <a href="api.html#Cassette.recurse"><code>recurse</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/overdub.jl#L717-L726">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.recurse" href="#Cassette.recurse"><code>Cassette.recurse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">recurse(context::Context, f, args...)</code></pre><p>Execute <code>f(args...)</code> overdubbed with respect to <code>context</code>.</p><p>This method performs exactly the same transformation as the default <a href="api.html#Cassette.overdub"><code>overdub</code></a> transformation, but is not meant to be overloaded. Thus, one can call <code>recurse</code> to &quot;continue&quot; recursively overdubbing a function when calling <code>overdub</code> directly on that function might&#39;ve dispatched to a contextual primitive.</p><p>To illustrate why <code>recurse</code> might be useful, consider the following example which utilizes <code>recurse</code> as part of a Cassette-based memoization implementation for the classic Fibonacci function:</p><pre><code class="language-none">using Cassette: Cassette, @context, overdub, recurse

fib(x) = x &lt; 3 ? 1 : fib(x - 2) + fib(x - 1)
fibtest(n) = fib(2 * n) + n

@context MemoizeCtx

function Cassette.overdub(ctx::MemoizeCtx, ::typeof(fib), x)
    result = get(ctx.metadata, x, 0)
    if result === 0
        result = recurse(ctx, fib, x)
        ctx.metadata[x] = result
    end
    return result
end</code></pre><p>See Cassette&#39;s Contextual Dispatch documentation for more details and examples.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/overdub.jl#L677-L713">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.prehook" href="#Cassette.prehook"><code>Cassette.prehook</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">prehook(context::Context, f, args...)</code></pre><p>Overload this Cassette method w.r.t. a given context in order to define a new contextual prehook for that context.</p><p>To understand when/how this method is called, see the documentation for <a href="api.html#Cassette.overdub"><code>overdub</code></a>.</p><p>Invoking <code>prehook</code> is a no-op by default (it immediately returns <code>nothing</code>).</p><p>See also: <a href="api.html#Cassette.overdub"><code>overdub</code></a>, <a href="api.html#Cassette.posthook"><code>posthook</code></a>, <a href="api.html#Cassette.recurse"><code>recurse</code></a>, <a href="api.html#Cassette.fallback"><code>fallback</code></a></p><p><strong>Examples</strong></p><p>Simple trace logging:</p><pre><code class="language-none">julia&gt; Cassette.@context PrintCtx;

julia&gt; Cassette.prehook(::PrintCtx, f, args...) = println(f, args)

julia&gt; Cassette.overdub(PrintCtx(), /, 1, 2)
float(1,)
AbstractFloat(1,)
Float64(1,)
sitofp(Float64, 1)
float(2,)
AbstractFloat(2,)
Float64(2,)
sitofp(Float64, 2)
/(1.0, 2.0)
div_float(1.0, 2.0)
0.5</code></pre><p>Counting the number of method invocations with one or more arguments of a given type:</p><pre><code class="language-none">julia&gt; mutable struct Count{T}
           count::Int
       end

julia&gt; Cassette.@context CountCtx;

julia&gt; Cassette.prehook(ctx::CountCtx{Count{T}}, f, arg::T, args::T...) where {T} = (ctx.metadata.count += 1)

# count the number of calls of the form `f(::Float64, ::Float64...)`
julia&gt; ctx = CountCtx(metadata = Count{Float64}(0));

julia&gt; Cassette.overdub(ctx, /, 1, 2)
0.5

julia&gt; ctx.metadata.count
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/context.jl#L319-L376">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.posthook" href="#Cassette.posthook"><code>Cassette.posthook</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">posthook(context::Context, output, f, args...)</code></pre><p>Overload this Cassette method w.r.t. a given context in order to define a new contextual posthook for that context.</p><p>To understand when/how this method is called, see the documentation for <a href="api.html#Cassette.overdub"><code>overdub</code></a>.</p><p>Invoking <code>posthook</code> is a no-op by default (it immediately returns <code>nothing</code>).</p><p>See also: <a href="api.html#Cassette.overdub"><code>overdub</code></a>, <a href="api.html#Cassette.prehook"><code>prehook</code></a>, <a href="api.html#Cassette.recurse"><code>recurse</code></a>, <a href="api.html#Cassette.fallback"><code>fallback</code></a></p><p><strong>Examples</strong></p><p>Simple trace logging:</p><pre><code class="language-none">julia&gt; Cassette.@context PrintCtx;

julia&gt; Cassette.posthook(::PrintCtx, output, f, args...) = println(output, &quot; = &quot;, f, args)

julia&gt; Cassette.overdub(PrintCtx(), /, 1, 2)
1.0 = sitofp(Float64, 1)
1.0 = Float64(1,)
1.0 = AbstractFloat(1,)
1.0 = float(1,)
2.0 = sitofp(Float64, 2)
2.0 = Float64(2,)
2.0 = AbstractFloat(2,)
2.0 = float(2,)
0.5 = div_float(1.0, 2.0)
0.5 = /(1.0, 2.0)
0.5</code></pre><p>Accumulate the sum of all numeric scalar outputs encountered in the trace:</p><pre><code class="language-none">julia&gt; mutable struct Accum
           x::Number
       end

julia&gt; Cassette.@context AccumCtx;

julia&gt; Cassette.posthook(ctx::AccumCtx{Accum}, out::Number, f, args...) = (ctx.metadata.x += out)

julia&gt; ctx = AccumCtx(metadata = Accum(0));

julia&gt; Cassette.overdub(ctx, /, 1, 2)
0.5

julia&gt; ctx.metadata.x
13.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/context.jl#L379-L435">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.fallback" href="#Cassette.fallback"><code>Cassette.fallback</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fallback(context::Context, f, args...)</code></pre><p>Overload this Cassette method w.r.t. a given context in order to define a new contextual execution fallback for that context.</p><p>To understand when/how this method is called, see the documentation for <a href="api.html#Cassette.overdub"><code>overdub</code></a> and <a href="api.html#Cassette.canrecurse"><code>canrecurse</code></a>.</p><p>By default, invoking <code>fallback(context, f, args...)</code> will simply call <code>f(args...)</code> (with all arguments automatically untagged, if <code>hastagging(typeof(context))</code>).</p><p>See also:  <a href="api.html#Cassette.canrecurse"><code>canrecurse</code></a>, <a href="api.html#Cassette.overdub"><code>overdub</code></a>, <a href="api.html#Cassette.recurse"><code>recurse</code></a>, <a href="api.html#Cassette.prehook"><code>prehook</code></a>, <a href="api.html#Cassette.posthook"><code>posthook</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/context.jl#L438-L453">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.canrecurse" href="#Cassette.canrecurse"><code>Cassette.canrecurse</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">canrecurse(context::Context, f, args...)</code></pre><p>Return <code>true</code> if <code>f(args...)</code> has a lowered IR representation that Cassette can overdub, return <code>false</code> otherwise.</p><p>Alternatively, but equivalently:</p><p>Return <code>false</code> if <code>recurse(context, f, args...)</code> directly translates to <code>fallback(context, f, args...)</code>, return <code>true</code> otherwise.</p><p>Note that unlike <code>overdub</code>, <code>fallback</code>, etc., this function is not intended to be overloaded.</p><p>See also:  <a href="api.html#Cassette.overdub"><code>overdub</code></a>, <a href="api.html#Cassette.fallback"><code>fallback</code></a>, <a href="api.html#Cassette.recurse"><code>recurse</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/context.jl#L466-L482">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.@pass" href="#Cassette.@pass"><code>Cassette.@pass</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">Cassette.@pass transform</code></pre><p>Return a Cassette pass that can be provided to the <code>Context</code> constructor&#39;s <code>pass</code> keyword argument in order to apply <code>transform</code> to the lowered IR representations of all methods invoked during contextual execution.</p><p><code>transform</code> must be a Julia object that is callable with the following signature:</p><pre><code class="language-none">transform(::Type{&lt;:Context}, ::Cassette.Reflection)::Union{Expr,CodeInfo}</code></pre><p>If <code>isa(transform(...), Expr)</code>, then the returned <code>Expr</code> will be emitted immediately without any additional processing. Otherwise, if <code>isa(transform(...), CodeInfo)</code>, then the returned <code>CodeInfo</code> will undergo the rest of Cassette&#39;s overdubbing transformation before being emitted from the <code>overdub</code> generator.</p><p>Two special <code>Expr</code> heads are available to Cassette pass authors that are not normally valid in Julia IR. <code>Expr</code>s with these heads can be used to interact with the downstream built-in Cassette passes that consume them.</p><ul><li><p><code>:nooverdub</code>: Wrap an <code>Expr</code> with this head value around the first argument in an   <code>Expr(:call)</code> to tell downstream built-in Cassette passes not to overdub that call. For   example, <code>Expr(:call, Expr(:nooverdub, GlobalRef(MyModule, :myfunc)), args...)</code>.</p></li><li><p><code>:contextslot</code>: Cassette will replace any <code>Expr(:contextslot)</code> with the actual <code>SlotNumber</code>   corresponding to the context object associated with the execution trace. For example, one   could construct an IR element that accesses the context&#39;s <code>metadata</code> field by emitting:   <code>Expr(:call, Expr(:nooverdub, GlobalRef(Core, :getfield)), Expr(:contextslot), QuoteNode(:metadata))</code></p></li></ul><p>Cassette provides a few IR-munging utility functions of interest to pass authors; for details, see <a href="api.html#Cassette.insert_statements!"><code>insert_statements!</code></a>, <a href="api.html#Cassette.replace_match!"><code>replace_match!</code></a>, and <a href="api.html#Cassette.is_ir_element"><code>is_ir_element</code></a>.</p><p>Note that the <code>@pass</code> macro expands to an <code>eval</code> call and thus should only be called at top-level. Furthermore, to avoid world-age issues, <code>transform</code> should not be overloaded after it has been registered with <code>@pass</code>.</p><p>Note also that <code>transform</code> should be &quot;relatively pure.&quot; More specifically, Julia&#39;s compiler has license to apply <code>transform</code> multiple times, even if only compiling a single method invocation once. Thus, it is required that <code>transform</code> always return a generally &quot;equivalent&quot; <code>CodeInfo</code> for a given context, method body, and signature. If your <code>transform</code> implementation is not naturally &quot;pure&quot; in this sense, then it is still possible to guarantee this property by memoizing your implementation (i.e. maintaining a cache of previously computed IR results, instead of recomputing results every time).</p><p>See also: <a href="api.html#Cassette.Context"><code>Context</code></a>, <a href="api.html#Cassette.overdub"><code>overdub</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/pass.jl#L5-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.replace_match!" href="#Cassette.replace_match!"><code>Cassette.replace_match!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">replace_match!(replace, ismatch, x)</code></pre><p>Return <code>x</code> with all subelements <code>y</code> replaced with <code>replace(y)</code> if <code>ismatch(y)</code>. If <code>!ismatch(y)</code>, but <code>y</code> is of type <code>Expr</code>, <code>Array</code>, or <code>SubArray</code>, then replace <code>y</code> in <code>x</code> with <code>replace_match!(replace, ismatch, y)</code>.</p><p>Generally, <code>x</code> should be of type <code>Expr</code>, <code>Array</code>, or <code>SubArray</code>.</p><p>Note that this function modifies <code>x</code> (and potentially its subelements) in-place.</p><p>See also: <a href="api.html#Cassette.insert_statements!"><code>insert_statements!</code></a>, <a href="api.html#Cassette.is_ir_element"><code>is_ir_element</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/pass.jl#L70-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.insert_statements!" href="#Cassette.insert_statements!"><code>Cassette.insert_statements!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">insert_statements!(code::Vector, codelocs::Vector, stmtcount, newstmts)</code></pre><p>For every statement <code>stmt</code> at position <code>i</code> in <code>code</code> for which <code>stmtcount(stmt, i)</code> returns an <code>Int</code>, remove <code>stmt</code>, and in its place, insert the statements returned by <code>newstmts(stmt, i)</code>. If <code>stmtcount(stmt, i)</code> returns <code>nothing</code>, leave <code>stmt</code> alone.</p><p>For every insertion, all downstream <code>SSAValue</code>s, label indices, etc. are incremented appropriately according to number of inserted statements.</p><p>Proper usage of this function dictates that following properties hold true:</p><ul><li><code>code</code> is expected to be a valid value for the <code>code</code> field of a <code>CodeInfo</code> object.</li><li><code>codelocs</code> is expected to be a valid value for the <code>codelocs</code> field of a <code>CodeInfo</code> object.</li><li><code>newstmts(stmt, i)</code> should return a <code>Vector</code> of valid IR statements.</li><li><code>stmtcount</code> and <code>newstmts</code> must obey <code>stmtcount(stmt, i) == length(newstmts(stmt, i))</code> if   <code>isa(stmtcount(stmt, i), Int)</code>.</li></ul><p>To gain a mental model for this function&#39;s behavior, consider the following scenario. Let&#39;s say our <code>code</code> object contains several statements:</p><pre><code class="language-none">code = Any[oldstmt1, oldstmt2, oldstmt3, oldstmt4, oldstmt5, oldstmt6]
codelocs = Int[1, 2, 3, 4, 5, 6]</code></pre><p>Let&#39;s also say that for our <code>stmtcount</code> returns <code>2</code> for <code>stmtcount(oldstmt2, 2)</code>, returns <code>3</code> for <code>stmtcount(oldstmt5, 5)</code>, and returns <code>nothing</code> for all other inputs. From this setup, we can think of <code>code</code>/<code>codelocs</code> being modified in the following manner:</p><pre><code class="language-none">newstmts2 = newstmts(oldstmt2, 2)
newstmts5 = newstmts(oldstmt5, 5)
code = Any[oldstmt1,
           newstmts2[1], newstmts2[2],
           oldstmt3, oldstmt4,
           newstmts5[1], newstmts5[2], newstmts5[3],
           oldstmt6]
codelocs = Int[1, 2, 2, 3, 4, 5, 5, 5, 6]</code></pre><p>See also: <a href="api.html#Cassette.replace_match!"><code>replace_match!</code></a>, <a href="api.html#Cassette.is_ir_element"><code>is_ir_element</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/pass.jl#L99-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.is_ir_element" href="#Cassette.is_ir_element"><code>Cassette.is_ir_element</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_ir_element(x, y, code::Vector)</code></pre><p>Return <code>true</code> if <code>x === y</code> or if <code>x</code> is an <code>SSAValue</code> such that <code>is_ir_element(code[x.id], y, code)</code> is <code>true</code>.</p><p>See also: <a href="api.html#Cassette.replace_match!"><code>replace_match!</code></a>, <a href="api.html#Cassette.insert_statements!"><code>insert_statements!</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/pass.jl#L174-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.OVERDUB_CONTEXT_NAME" href="#Cassette.OVERDUB_CONTEXT_NAME"><code>Cassette.OVERDUB_CONTEXT_NAME</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Cassette.OVERDUB_CONTEXT_NAME</code></pre><p>The variable name bound to <code>overdub</code>&#39;s <code>Context</code> argument in its <code>@generated</code> method definition.</p><p>This binding can be used to manually reference/destructure <code>overdub</code> arguments within <code>Expr</code> thunks emitted by user-provided passes.</p><p>See also: <a href="api.html#Cassette.OVERDUB_ARGUMENTS_NAME"><code>OVERDUB_ARGUMENTS_NAME</code></a>, <a href="api.html#Cassette.@pass"><code>@pass</code></a>, <a href="api.html#Cassette.overdub"><code>overdub</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/overdub.jl#L97-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.OVERDUB_ARGUMENTS_NAME" href="#Cassette.OVERDUB_ARGUMENTS_NAME"><code>Cassette.OVERDUB_ARGUMENTS_NAME</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Cassette.OVERDUB_ARGUMENTS_NAME</code></pre><p>The variable name bound to <code>overdub</code>&#39;s tuple of non-<code>Context</code> arguments in its <code>@generated</code> method definition.</p><p>This binding can be used to manually reference/destructure <code>overdub</code> arguments within <code>Expr</code> thunks emitted by user-provided passes.</p><p>See also: <a href="api.html#Cassette.OVERDUB_CONTEXT_NAME"><code>OVERDUB_CONTEXT_NAME</code></a>, <a href="api.html#Cassette.@pass"><code>@pass</code></a>, <a href="api.html#Cassette.overdub"><code>overdub</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/overdub.jl#L110-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.Reflection" href="#Cassette.Reflection"><code>Cassette.Reflection</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Cassette.Reflection</code></pre><p>A struct representing the information retrieved via <code>Cassette.reflect</code>.</p><p>A <code>Reflection</code> is essentially just a convenient bundle of information about a specific method invocation.</p><p><strong>Fields</strong></p><ul><li><p><code>signature</code>: the invocation signature (in <code>Tuple{...}</code> type form) for the invoked method.</p></li><li><p><code>method</code>: the <code>Method</code> object associated with the invoked method.</p></li><li><p><code>static_params</code>: a <code>Vector</code> representing the invoked method&#39;s static parameter list.</p></li><li><p><code>code_info</code>: the <code>CodeInfo</code> object associated with the invoked method.</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/overdub.jl#L5-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.tag" href="#Cassette.tag"><code>Cassette.tag</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tag(value, context::Context, metadata = Cassette.NoMetaData())</code></pre><p>Return <code>value</code> tagged w.r.t. <code>context</code>, optionally associating <code>metadata</code> with the returned <code>Tagged</code> instance.</p><p>Any provided <code>metadata</code> must obey the type constraints determined by Cassette&#39;s <a href="api.html#Cassette.metadatatype"><code>metadatatype</code></a> method.</p><p>Note that <code>hastagging(typeof(context))</code> must be <code>true</code> for a value to be tagged w.r.t. to <code>context</code>.</p><p>See also: <a href="api.html#Cassette.untag"><code>untag</code></a>, <a href="api.html#Cassette.enabletagging"><code>enabletagging</code></a>, <a href="api.html#Cassette.hastagging"><code>hastagging</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/tagging.jl#L326-L341">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.untag" href="#Cassette.untag"><code>Cassette.untag</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">untag(x, context::Context)</code></pre><p>Return <code>x</code> untagged w.r.t. <code>context</code> if <code>istagged(x, context)</code>, otherwise return <code>x</code> directly.</p><p>In other words, <code>untag(tag(x, context), context) === x</code> is always <code>true</code>.</p><p>If <code>!istagged(x, context)</code>, then <code>untag(x, context) === x</code> is <code>true</code>.</p><p>See also: <a href="api.html#Cassette.tag"><code>tag</code></a>, <a href="api.html#Cassette.istagged"><code>istagged</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/tagging.jl#L350-L363">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.untagtype" href="#Cassette.untagtype"><code>Cassette.untagtype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">untagtype(::Type{T}, ::Type{C&lt;:Context})</code></pre><p>Return <code>typeof(untag(::T, ::C))</code>.</p><p>In other words, <code>untagtype(typeof(tag(x, context)), typeof(context)) === typeof(x)</code> is always <code>true</code>.</p><p>If <code>!istaggedtype(T, C)</code>, then <code>untagtype(T, C) === T</code> is <code>true</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/tagging.jl#L368-L379">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.metadata" href="#Cassette.metadata"><code>Cassette.metadata</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">metadata(x, context::Context)</code></pre><p>Return the <code>metadata</code> attached to <code>x</code> if <code>hasmetadata(x, context)</code>, otherwise return <code>Cassette.NoMetaData()</code>.</p><p>In other words, <code>metadata(tag(x, context, m), context) === m</code> is always <code>true</code>.</p><p>If <code>!hasmetadata(x, context)</code>, then <code>metadata(x, context) === Cassette.NoMetaData()</code> is <code>true</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/tagging.jl#L384-L396">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.metadatatype" href="#Cassette.metadatatype"><code>Cassette.metadatatype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">metadatatype(::Type{&lt;:Context}, ::Type{T})</code></pre><p>Overload this Cassette method w.r.t. a given context to define the type of metadata that can be tagged to values of type <code>T</code> within that context.</p><p>By default, this method is set such that associating metadata with any tagged value is disallowed.</p><p>Cassette uses <code>metadatatype</code> to statically compute a context-specific metadata type hiearchy for all tagged values within overdubbed programs. To gain a mental model for this mechanism, consider a simple struct definition as follows:</p><pre><code class="language-none">struct Foo
    x::Int
    y::Complex{Int}
end</code></pre><p>Now, Cassette can use <code>metadatatype</code> to determine type constraints for metadata structures associated with tagged values of type <code>Foo</code>. In psuedo-Julia-code, these metadata structures might look something like the following for <code>Foo</code>:</p><pre><code class="language-none">struct IntMeta
    data::metadatatype(Ctx, Int)
    meta::Cassette.NoMetaMeta
end

struct ComplexIntMeta
    data::metadatatype(Ctx, Complex{Int})
    meta::NamedTuple{(:re,:im),Tuple{IntMeta,IntMeta}}
end

struct FooMeta
    data::metadatatype(Ctx, Foo)
    meta::NamedTuple{(:x,:y),Tuple{IntMeta,ComplexIntMeta}
end</code></pre><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; Cassette.@context Ctx;

# any value of type `Number` can now be tagged with metadata of type `Number`
julia&gt; Cassette.metadatatype(::Type{&lt;:Ctx}, ::Type{&lt;:Number}) = Number

# any value of type `T&lt;:Number` can now be tagged with metadata of type `T`
julia&gt; Cassette.metadatatype(::Type{&lt;:Ctx}, ::Type{T}) where {T&lt;:Number} = T

# any value of type `T&lt;:Number` can now be tagged with metadata of type `promote_type(T, M)`
# where `M` is the type of the trace-local metadata associated with the context
julia&gt; Cassette.metadatatype(::Type{&lt;:Ctx{M}}, ::Type{T}) where {M&lt;:Number,T&lt;:Number} = promote_type(T, M)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/tagging.jl#L174-L232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.hasmetadata" href="#Cassette.hasmetadata"><code>Cassette.hasmetadata</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hasmetadata(x, context::Context)</code></pre><p>Return <code>true</code> if <code>!isa(metadata(x, context), Cassette.NoMetaData)</code>, return <code>false</code> otherwise.</p><p>In other words, <code>hasmetadata(tag(x, context, m), context)</code> is always <code>true</code> and <code>hasmetadata(tag(x, context), context)</code> is always <code>false</code>.</p><p>See also: <a href="api.html#Cassette.metadata"><code>metadata</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/tagging.jl#L435-L446">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.istagged" href="#Cassette.istagged"><code>Cassette.istagged</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">istagged(x, context::Context)</code></pre><p>Return <code>true</code> if <code>x</code> is tagged w.r.t. <code>context</code>, return <code>false</code> otherwise.</p><p>In other words, <code>istagged(tag(x, context), context)</code> is always <code>true</code>.</p><p>See also: <a href="api.html#Cassette.tag"><code>tag</code></a>, <a href="api.html#Cassette.istaggedtype"><code>istaggedtype</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/tagging.jl#L405-L415">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Cassette.istaggedtype" href="#Cassette.istaggedtype"><code>Cassette.istaggedtype</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">istaggedtype(::Type{T}, ::Type{C&lt;:Context})</code></pre><p>Return <code>typeof(istagged(::T, ::C))</code>.</p><p>In other words, <code>istaggedtype(typeof(tag(x, context)), typeof(context))</code> is always <code>true</code>.</p><p>See also: <a href="api.html#Cassette.tag"><code>tag</code></a>, <a href="api.html#Cassette.istagged"><code>istagged</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/jrevels/Cassette.jl/blob/d655db2f80152629deced619a0f32e6df795b965/src/tagging.jl#L420-L430">source</a></section><footer><hr/><a class="previous" href="contextualtagging.html"><span class="direction">Previous</span><span class="title">Contextual Tagging of Values</span></a><a class="next" href="relatedwork.html"><span class="direction">Next</span><span class="title">Related Work</span></a></footer></article></body></html>
